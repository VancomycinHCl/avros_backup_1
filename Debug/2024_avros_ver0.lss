
2024_avros_ver0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  000005a0  00000634  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000005a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000612  00800200  00800200  00000634  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000634  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000664  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000f0  00000000  00000000  000006a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000127a  00000000  00000000  00000798  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e26  00000000  00000000  00001a12  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ae6  00000000  00000000  00002838  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000014c  00000000  00000000  00003320  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000741  00000000  00000000  0000346c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000020b  00000000  00000000  00003bad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  00003db8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	81 c0       	rjmp	.+258    	; 0x108 <__bad_interrupt>
   6:	00 00       	nop
   8:	7f c0       	rjmp	.+254    	; 0x108 <__bad_interrupt>
   a:	00 00       	nop
   c:	7d c0       	rjmp	.+250    	; 0x108 <__bad_interrupt>
   e:	00 00       	nop
  10:	7b c0       	rjmp	.+246    	; 0x108 <__bad_interrupt>
  12:	00 00       	nop
  14:	79 c0       	rjmp	.+242    	; 0x108 <__bad_interrupt>
  16:	00 00       	nop
  18:	77 c0       	rjmp	.+238    	; 0x108 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	75 c0       	rjmp	.+234    	; 0x108 <__bad_interrupt>
  1e:	00 00       	nop
  20:	73 c0       	rjmp	.+230    	; 0x108 <__bad_interrupt>
  22:	00 00       	nop
  24:	71 c0       	rjmp	.+226    	; 0x108 <__bad_interrupt>
  26:	00 00       	nop
  28:	6f c0       	rjmp	.+222    	; 0x108 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	6d c0       	rjmp	.+218    	; 0x108 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6b c0       	rjmp	.+214    	; 0x108 <__bad_interrupt>
  32:	00 00       	nop
  34:	69 c0       	rjmp	.+210    	; 0x108 <__bad_interrupt>
  36:	00 00       	nop
  38:	67 c0       	rjmp	.+206    	; 0x108 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	65 c0       	rjmp	.+202    	; 0x108 <__bad_interrupt>
  3e:	00 00       	nop
  40:	63 c0       	rjmp	.+198    	; 0x108 <__bad_interrupt>
  42:	00 00       	nop
  44:	43 c1       	rjmp	.+646    	; 0x2cc <__vector_17>
  46:	00 00       	nop
  48:	5f c0       	rjmp	.+190    	; 0x108 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	5d c0       	rjmp	.+186    	; 0x108 <__bad_interrupt>
  4e:	00 00       	nop
  50:	5b c0       	rjmp	.+182    	; 0x108 <__bad_interrupt>
  52:	00 00       	nop
  54:	59 c0       	rjmp	.+178    	; 0x108 <__bad_interrupt>
  56:	00 00       	nop
  58:	57 c0       	rjmp	.+174    	; 0x108 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	55 c0       	rjmp	.+170    	; 0x108 <__bad_interrupt>
  5e:	00 00       	nop
  60:	53 c0       	rjmp	.+166    	; 0x108 <__bad_interrupt>
  62:	00 00       	nop
  64:	51 c0       	rjmp	.+162    	; 0x108 <__bad_interrupt>
  66:	00 00       	nop
  68:	4f c0       	rjmp	.+158    	; 0x108 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	4d c0       	rjmp	.+154    	; 0x108 <__bad_interrupt>
  6e:	00 00       	nop
  70:	4b c0       	rjmp	.+150    	; 0x108 <__bad_interrupt>
  72:	00 00       	nop
  74:	49 c0       	rjmp	.+146    	; 0x108 <__bad_interrupt>
  76:	00 00       	nop
  78:	47 c0       	rjmp	.+142    	; 0x108 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	45 c0       	rjmp	.+138    	; 0x108 <__bad_interrupt>
  7e:	00 00       	nop
  80:	43 c0       	rjmp	.+134    	; 0x108 <__bad_interrupt>
  82:	00 00       	nop
  84:	41 c0       	rjmp	.+130    	; 0x108 <__bad_interrupt>
  86:	00 00       	nop
  88:	3f c0       	rjmp	.+126    	; 0x108 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	3d c0       	rjmp	.+122    	; 0x108 <__bad_interrupt>
  8e:	00 00       	nop
  90:	3b c0       	rjmp	.+118    	; 0x108 <__bad_interrupt>
  92:	00 00       	nop
  94:	39 c0       	rjmp	.+114    	; 0x108 <__bad_interrupt>
  96:	00 00       	nop
  98:	37 c0       	rjmp	.+110    	; 0x108 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	35 c0       	rjmp	.+106    	; 0x108 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	33 c0       	rjmp	.+102    	; 0x108 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	31 c0       	rjmp	.+98     	; 0x108 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	2f c0       	rjmp	.+94     	; 0x108 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	2d c0       	rjmp	.+90     	; 0x108 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	2b c0       	rjmp	.+86     	; 0x108 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	29 c0       	rjmp	.+82     	; 0x108 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	27 c0       	rjmp	.+78     	; 0x108 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	25 c0       	rjmp	.+74     	; 0x108 <__bad_interrupt>
  be:	00 00       	nop
  c0:	23 c0       	rjmp	.+70     	; 0x108 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	21 c0       	rjmp	.+66     	; 0x108 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	1f c0       	rjmp	.+62     	; 0x108 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	1d c0       	rjmp	.+58     	; 0x108 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	1b c0       	rjmp	.+54     	; 0x108 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	19 c0       	rjmp	.+50     	; 0x108 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	17 c0       	rjmp	.+46     	; 0x108 <__bad_interrupt>
  da:	00 00       	nop
  dc:	15 c0       	rjmp	.+42     	; 0x108 <__bad_interrupt>
  de:	00 00       	nop
  e0:	13 c0       	rjmp	.+38     	; 0x108 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_clear_bss>:
  f4:	28 e0       	ldi	r18, 0x08	; 8
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
  fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
  fe:	a2 31       	cpi	r26, 0x12	; 18
 100:	b2 07       	cpc	r27, r18
 102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
 104:	e5 d0       	rcall	.+458    	; 0x2d0 <main>
 106:	4a c2       	rjmp	.+1172   	; 0x59c <_exit>

00000108 <__bad_interrupt>:
 108:	7b cf       	rjmp	.-266    	; 0x0 <__vectors>

0000010a <delay_us>:

.global delay_us
.global delay_us_atom
delay_us:
   
    sbiw  r24, 1        ; 2		r24:r25减1（使用正确的寄存器对和逗号）
 10a:	01 97       	sbiw	r24, 0x01	; 1
	breq  end_loop      ; 1 or 2   如果都为0，则跳到end_loop
 10c:	71 f0       	breq	.+28     	; 0x12a <end_loop>

0000010e <delay_loop_0>:
	...
    nop
    nop
    nop
	nop
	nop
    breq  end_loop      ; 如果计数到0，则结束循环
 122:	19 f0       	breq	.+6      	; 0x12a <end_loop>
    clr   r26
 124:	aa 27       	eor	r26, r26
    sbiw  r24, 1        ; 再次减1
 126:	01 97       	sbiw	r24, 0x01	; 1
    brne  delay_loop_0  ; 如果不为0，继续循环
 128:	91 f7       	brne	.-28     	; 0x10e <delay_loop_0>

0000012a <end_loop>:

end_loop:
    // sei                 ; 1 重新启用中断
    ret                 ; 4 返回
 12a:	08 95       	ret

0000012c <delay_us_atom>:


delay_us_atom:
    cli;
 12c:	f8 94       	cli
    sbiw  r24, 1        ; 2		r24:r25减1（使用正确的寄存器对和逗号）
 12e:	01 97       	sbiw	r24, 0x01	; 1
	breq  end_loop      ; 1 or 2   如果都为0，则跳到end_loop
 130:	e1 f3       	breq	.-8      	; 0x12a <end_loop>

00000132 <delay_loop_atom>:
	...
    nop
    nop
    nop
	nop
	nop
    breq  end_loop_atom      ; 如果计数到0，则结束循环
 146:	19 f0       	breq	.+6      	; 0x14e <end_loop_atom>
    clr   r26
 148:	aa 27       	eor	r26, r26
    sbiw  r24, 1        ; 再次减1
 14a:	01 97       	sbiw	r24, 0x01	; 1
    brne  delay_loop_atom  ; 如果不为0，继续循环
 14c:	91 f7       	brne	.-28     	; 0x132 <delay_loop_atom>

0000014e <end_loop_atom>:

end_loop_atom:
    sei                 ; 1 重新启用中断
 14e:	78 94       	sei
 150:	08 95       	ret

00000152 <startup_thread>:
.equ MAX_THREADS,2
.equ SREG,0x3F
.equ TLB_SIZE,0x04

startup_thread:
 	lds r16, currentThread       ; 加载 currentThread 的值到 r16
 152:	00 91 00 02 	lds	r16, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
    ldi r17, TLB_SIZE            ; 加载 TCB 的大小到 r17 (4 字节)
 156:	14 e0       	ldi	r17, 0x04	; 4
    mul r16, r17                 ; r0:r1 = r16 * r17 (结果在 r0:r1)
 158:	01 9f       	mul	r16, r17
    ldi r30, lo8(threadList)     ; 加载 threadList 的低位地址到 Z 寄存器 (r30)
 15a:	e2 e0       	ldi	r30, 0x02	; 2
    ldi r31, hi8(threadList)     ; 加载 threadList 的高位地址到 Z 寄存器 (r31)
 15c:	f8 e0       	ldi	r31, 0x08	; 8
    add r30, r0                  ; 将乘法结果的低位加到 Z 寄存器的低位
 15e:	e0 0d       	add	r30, r0
    adc r31, r1                  ; 将乘法结果的高位加到 Z 寄存器的高位，考虑进位
 160:	f1 1d       	adc	r31, r1
    clr r1                       ; 清除 r1，因为 mul 指令会使用到它
 162:	11 24       	eor	r1, r1
	ld  r16, Z+
 164:	01 91       	ld	r16, Z+
	ld  r17, Z
 166:	10 81       	ld	r17, Z
    out SPL, r16
 168:	0d bf       	out	0x3d, r16	; 61
    out SPH, r17
 16a:	1e bf       	out	0x3e, r17	; 62

	pop r31 
 16c:	ff 91       	pop	r31
	pop r30 
 16e:	ef 91       	pop	r30
	pop r29 
 170:	df 91       	pop	r29
	pop r28 
 172:	cf 91       	pop	r28
	pop r27 
 174:	bf 91       	pop	r27
	pop r26 
 176:	af 91       	pop	r26
	pop r25 
 178:	9f 91       	pop	r25
	pop r24 
 17a:	8f 91       	pop	r24
	pop r23 
 17c:	7f 91       	pop	r23
	pop r22 
 17e:	6f 91       	pop	r22
	pop r21 
 180:	5f 91       	pop	r21
	pop r20 
 182:	4f 91       	pop	r20
	pop r19 
 184:	3f 91       	pop	r19
	pop r18 
 186:	2f 91       	pop	r18
	pop r17 
 188:	1f 91       	pop	r17
	pop r16 
 18a:	0f 91       	pop	r16
	pop r15 
 18c:	ff 90       	pop	r15
	pop r14 
 18e:	ef 90       	pop	r14
	pop r13 
 190:	df 90       	pop	r13
	pop r12 
 192:	cf 90       	pop	r12
	pop r11 
 194:	bf 90       	pop	r11
	pop r10 
 196:	af 90       	pop	r10
	pop r9 
 198:	9f 90       	pop	r9
	pop r8 
 19a:	8f 90       	pop	r8
	pop r7 
 19c:	7f 90       	pop	r7
	pop r6 
 19e:	6f 90       	pop	r6
	pop r5 
 1a0:	5f 90       	pop	r5
	pop r4 
 1a2:	4f 90       	pop	r4
	pop r3 
 1a4:	3f 90       	pop	r3
	pop r2 
 1a6:	2f 90       	pop	r2
	pop r1 
 1a8:	1f 90       	pop	r1
    ; ... 恢复其他寄存器 ...
    pop r0
 1aa:	0f 90       	pop	r0
    out SREG, r0
 1ac:	0f be       	out	0x3f, r0	; 63
    pop r0
 1ae:	0f 90       	pop	r0
	sei;    恢复中断使能
 1b0:	78 94       	sei
    ; ... 恢复其他寄存器 ...
 1b2:	08 95       	ret

000001b4 <switch_threads>:
.equ MAX_THREADS,2
.equ SREG,0x3F
.equ TLB_SIZE,0x08

switch_threads:
	rjmp save_prev_thread
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <save_prev_thread>

000001b6 <save_prev_thread>:
save_prev_thread:
    ; 保存当前线程的栈指针
	cli
 1b6:	f8 94       	cli
    push r0
 1b8:	0f 92       	push	r0
    in r0, SREG
 1ba:	0f b6       	in	r0, 0x3f	; 63
    push r0
 1bc:	0f 92       	push	r0
    ; ... 保存其他寄存器 ...
	push r1
 1be:	1f 92       	push	r1
	push r2
 1c0:	2f 92       	push	r2
	push r3
 1c2:	3f 92       	push	r3
	push r4
 1c4:	4f 92       	push	r4
	push r5
 1c6:	5f 92       	push	r5
	push r6
 1c8:	6f 92       	push	r6
	push r7
 1ca:	7f 92       	push	r7
	push r8
 1cc:	8f 92       	push	r8
	push r9
 1ce:	9f 92       	push	r9
	push r10
 1d0:	af 92       	push	r10
	push r11
 1d2:	bf 92       	push	r11
	push r12
 1d4:	cf 92       	push	r12
	push r13
 1d6:	df 92       	push	r13
	push r14
 1d8:	ef 92       	push	r14
	push r15
 1da:	ff 92       	push	r15
	push r16
 1dc:	0f 93       	push	r16
	push r17
 1de:	1f 93       	push	r17
	push r18
 1e0:	2f 93       	push	r18
	push r19
 1e2:	3f 93       	push	r19
	push r20
 1e4:	4f 93       	push	r20
	push r21
 1e6:	5f 93       	push	r21
	push r22
 1e8:	6f 93       	push	r22
	push r23
 1ea:	7f 93       	push	r23
	push r24
 1ec:	8f 93       	push	r24
	push r25
 1ee:	9f 93       	push	r25
	push r26
 1f0:	af 93       	push	r26
	push r27
 1f2:	bf 93       	push	r27
	push r28
 1f4:	cf 93       	push	r28
	push r29
 1f6:	df 93       	push	r29
	push r30
 1f8:	ef 93       	push	r30
	push r31
 1fa:	ff 93       	push	r31

    ; 保存当前栈指针到 threadList[currentThread].stackPointer
	lds r16, currentThread   ; 加载 currentThread 的值到 r16
 1fc:	00 91 00 02 	lds	r16, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
	ldi r17, TLB_SIZE		 ; 加载 TCB 的大小到 r17 (4 字节)
 200:	18 e0       	ldi	r17, 0x08	; 8
	mul r16, r17			 ; r0:r1 = r16 * r17 (结果在 r0:r1)
 202:	01 9f       	mul	r16, r17
	in r18, SPL
 204:	2d b7       	in	r18, 0x3d	; 61
	in r19, SPH
 206:	3e b7       	in	r19, 0x3e	; 62
	ldi r30, lo8(threadList) ; 加载 threadList 的低位地址到 Z 寄存器 (r30)
 208:	e2 e0       	ldi	r30, 0x02	; 2
	ldi r31, hi8(threadList) ; 加载 threadList 的高位地址到 Z 寄存器 (r31)
 20a:	f8 e0       	ldi	r31, 0x08	; 8
	add r30, r0				 ; 将乘法结果的低位加到 Z 寄存器的低位
 20c:	e0 0d       	add	r30, r0
	adc r31, r1				 ; 将乘法结果的高位加到 Z 寄存器的高位，考虑进位
 20e:	f1 1d       	adc	r31, r1
	st Z+, r18
 210:	21 93       	st	Z+, r18
	st Z+, r19
 212:	31 93       	st	Z+, r19

	
	rcall scheduling_thread  ;
 214:	11 d1       	rcall	.+546    	; 0x438 <scheduling_thread>

00000216 <restore_next_thread>:

restore_next_thread:
    ; 恢复下一个线程的栈指针
	lds r16, currentThread       ; 加载 currentThread 的值到 r16
 216:	00 91 00 02 	lds	r16, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
    ldi r17, TLB_SIZE            ; 加载 TCB 的大小到 r17 (4 字节)
 21a:	18 e0       	ldi	r17, 0x08	; 8
    mul r16, r17                 ; r0:r1 = r16 * r17 (结果在 r0:r1)
 21c:	01 9f       	mul	r16, r17
    ldi r30, lo8(threadList)     ; 加载 threadList 的低位地址到 Z 寄存器 (r30)
 21e:	e2 e0       	ldi	r30, 0x02	; 2
    ldi r31, hi8(threadList)     ; 加载 threadList 的高位地址到 Z 寄存器 (r31)
 220:	f8 e0       	ldi	r31, 0x08	; 8
    add r30, r0                  ; 将乘法结果的低位加到 Z 寄存器的低位
 222:	e0 0d       	add	r30, r0
    adc r31, r1                  ; 将乘法结果的高位加到 Z 寄存器的高位，考虑进位
 224:	f1 1d       	adc	r31, r1
    clr r1                       ; 清除 r1，因为 mul 指令会使用到它
 226:	11 24       	eor	r1, r1
	ld  r16, Z+
 228:	01 91       	ld	r16, Z+
	ld  r17, Z
 22a:	10 81       	ld	r17, Z
    out SPL, r16
 22c:	0d bf       	out	0x3d, r16	; 61
    out SPH, r17
 22e:	1e bf       	out	0x3e, r17	; 62
	pop r31 
 230:	ff 91       	pop	r31
	pop r30 
 232:	ef 91       	pop	r30
	pop r29 
 234:	df 91       	pop	r29
	pop r28 
 236:	cf 91       	pop	r28
	pop r27 
 238:	bf 91       	pop	r27
	pop r26 
 23a:	af 91       	pop	r26
	pop r25 
 23c:	9f 91       	pop	r25
	pop r24 
 23e:	8f 91       	pop	r24
	pop r23 
 240:	7f 91       	pop	r23
	pop r22 
 242:	6f 91       	pop	r22
	pop r21 
 244:	5f 91       	pop	r21
	pop r20 
 246:	4f 91       	pop	r20
	pop r19 
 248:	3f 91       	pop	r19
	pop r18 
 24a:	2f 91       	pop	r18
	pop r17 
 24c:	1f 91       	pop	r17
	pop r16 
 24e:	0f 91       	pop	r16
	pop r15 
 250:	ff 90       	pop	r15
	pop r14 
 252:	ef 90       	pop	r14
	pop r13 
 254:	df 90       	pop	r13
	pop r12 
 256:	cf 90       	pop	r12
	pop r11 
 258:	bf 90       	pop	r11
	pop r10 
 25a:	af 90       	pop	r10
	pop r9 
 25c:	9f 90       	pop	r9
	pop r8 
 25e:	8f 90       	pop	r8
	pop r7 
 260:	7f 90       	pop	r7
	pop r6 
 262:	6f 90       	pop	r6
	pop r5 
 264:	5f 90       	pop	r5
	pop r4 
 266:	4f 90       	pop	r4
	pop r3 
 268:	3f 90       	pop	r3
	pop r2 
 26a:	2f 90       	pop	r2
	pop r1 
 26c:	1f 90       	pop	r1
    ; ... 恢复其他寄存器 ...
    pop r0
 26e:	0f 90       	pop	r0
    out SREG, r0
 270:	0f be       	out	0x3f, r0	; 63
    pop r0
 272:	0f 90       	pop	r0
    ; ... 恢复其他寄存器 ...
	sei
 274:	78 94       	sei
	ret
 276:	08 95       	ret

00000278 <timer_init>:
#include "user_func/user_func.h"

// static int i = 0;

// Timer configuration for ATMEL Mega 2560
void timer_init() {
 278:	cf 93       	push	r28
 27a:	df 93       	push	r29
 27c:	cd b7       	in	r28, 0x3d	; 61
 27e:	de b7       	in	r29, 0x3e	; 62
	// Set the Timer Mode to CTC
	TCCR1B |= (1 << WGM12);
 280:	81 e8       	ldi	r24, 0x81	; 129
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	21 e8       	ldi	r18, 0x81	; 129
 286:	30 e0       	ldi	r19, 0x00	; 0
 288:	f9 01       	movw	r30, r18
 28a:	20 81       	ld	r18, Z
 28c:	28 60       	ori	r18, 0x08	; 8
 28e:	fc 01       	movw	r30, r24
 290:	20 83       	st	Z, r18
	// Set the value that you want to count to
	OCR1A = 31248; // This will allow the timer to count for 1 second with a 16MHz clock 15624 for 1s
 292:	88 e8       	ldi	r24, 0x88	; 136
 294:	90 e0       	ldi	r25, 0x00	; 0
 296:	20 e1       	ldi	r18, 0x10	; 16
 298:	3a e7       	ldi	r19, 0x7A	; 122
 29a:	fc 01       	movw	r30, r24
 29c:	31 83       	std	Z+1, r19	; 0x01
 29e:	20 83       	st	Z, r18
	// Set the prescaler to 256 and start the timer
	TCCR1B |= (1 << CS12);
 2a0:	81 e8       	ldi	r24, 0x81	; 129
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	21 e8       	ldi	r18, 0x81	; 129
 2a6:	30 e0       	ldi	r19, 0x00	; 0
 2a8:	f9 01       	movw	r30, r18
 2aa:	20 81       	ld	r18, Z
 2ac:	24 60       	ori	r18, 0x04	; 4
 2ae:	fc 01       	movw	r30, r24
 2b0:	20 83       	st	Z, r18
	// Enable the compare interrupt
	TIMSK1 |= (1 << OCIE1A);
 2b2:	8f e6       	ldi	r24, 0x6F	; 111
 2b4:	90 e0       	ldi	r25, 0x00	; 0
 2b6:	2f e6       	ldi	r18, 0x6F	; 111
 2b8:	30 e0       	ldi	r19, 0x00	; 0
 2ba:	f9 01       	movw	r30, r18
 2bc:	20 81       	ld	r18, Z
 2be:	22 60       	ori	r18, 0x02	; 2
 2c0:	fc 01       	movw	r30, r24
 2c2:	20 83       	st	Z, r18
	// Initialize global interrupts
	// sei();
}
 2c4:	00 00       	nop
 2c6:	df 91       	pop	r29
 2c8:	cf 91       	pop	r28
 2ca:	08 95       	ret

000002cc <__vector_17>:


// Interrupt Service Routine for Timer1 compare match
ISR(TIMER1_COMPA_vect,ISR_NAKED ) 
{
	asm volatile("rjmp switch_threads\n");
 2cc:	73 cf       	rjmp	.-282    	; 0x1b4 <switch_threads>
	...

000002d0 <main>:
}




int main() {
 2d0:	cf 93       	push	r28
 2d2:	df 93       	push	r29
 2d4:	cd b7       	in	r28, 0x3d	; 61
 2d6:	de b7       	in	r29, 0x3e	; 62
	// Initialize the timer
	timer_init();
 2d8:	cf df       	rcall	.-98     	; 0x278 <timer_init>
	DDRB |= (1 << DDB7); 
 2da:	84 e2       	ldi	r24, 0x24	; 36
 2dc:	90 e0       	ldi	r25, 0x00	; 0
 2de:	24 e2       	ldi	r18, 0x24	; 36
 2e0:	30 e0       	ldi	r19, 0x00	; 0
 2e2:	f9 01       	movw	r30, r18
 2e4:	20 81       	ld	r18, Z
 2e6:	20 68       	ori	r18, 0x80	; 128
 2e8:	fc 01       	movw	r30, r24
 2ea:	20 83       	st	Z, r18
	DDRA |= (1 << DDA1);
 2ec:	81 e2       	ldi	r24, 0x21	; 33
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	21 e2       	ldi	r18, 0x21	; 33
 2f2:	30 e0       	ldi	r19, 0x00	; 0
 2f4:	f9 01       	movw	r30, r18
 2f6:	20 81       	ld	r18, Z
 2f8:	22 60       	ori	r18, 0x02	; 2
 2fa:	fc 01       	movw	r30, r24
 2fc:	20 83       	st	Z, r18
	PORTB |= 0xFF;
 2fe:	85 e2       	ldi	r24, 0x25	; 37
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	fc 01       	movw	r30, r24
 304:	80 81       	ld	r24, Z
 306:	85 e2       	ldi	r24, 0x25	; 37
 308:	90 e0       	ldi	r25, 0x00	; 0
 30a:	2f ef       	ldi	r18, 0xFF	; 255
 30c:	fc 01       	movw	r30, r24
 30e:	20 83       	st	Z, r18
	PORTA |= 0xFF;
 310:	82 e2       	ldi	r24, 0x22	; 34
 312:	90 e0       	ldi	r25, 0x00	; 0
 314:	fc 01       	movw	r30, r24
 316:	80 81       	ld	r24, Z
 318:	82 e2       	ldi	r24, 0x22	; 34
 31a:	90 e0       	ldi	r25, 0x00	; 0
 31c:	2f ef       	ldi	r18, 0xFF	; 255
 31e:	fc 01       	movw	r30, r24
 320:	20 83       	st	Z, r18
	
	setup_threads(&threadList[0],thread_stack_0,&thread0_main,0);
 322:	20 e0       	ldi	r18, 0x00	; 0
 324:	30 e0       	ldi	r19, 0x00	; 0
 326:	46 e7       	ldi	r20, 0x76	; 118
 328:	52 e0       	ldi	r21, 0x02	; 2
 32a:	62 e0       	ldi	r22, 0x02	; 2
 32c:	72 e0       	ldi	r23, 0x02	; 2
 32e:	82 e0       	ldi	r24, 0x02	; 2
 330:	98 e0       	ldi	r25, 0x08	; 8
 332:	0b d0       	rcall	.+22     	; 0x34a <setup_threads>
	setup_threads(&threadList[1],thread_stack_1,&thread1_main,1);
 334:	21 e0       	ldi	r18, 0x01	; 1
 336:	30 e0       	ldi	r19, 0x00	; 0
 338:	4b ea       	ldi	r20, 0xAB	; 171
 33a:	52 e0       	ldi	r21, 0x02	; 2
 33c:	62 e0       	ldi	r22, 0x02	; 2
 33e:	76 e0       	ldi	r23, 0x06	; 6
 340:	8a e0       	ldi	r24, 0x0A	; 10
 342:	98 e0       	ldi	r25, 0x08	; 8
	startup_thread();
 344:	02 d0       	rcall	.+4      	; 0x34a <setup_threads>
 346:	05 df       	rcall	.-502    	; 0x152 <startup_thread>
	// Main loop
	while(1) 
	{
		// printf("asdf");
	}
 348:	ff cf       	rjmp	.-2      	; 0x348 <main+0x78>

0000034a <setup_threads>:
#include <string.h>

// extern const uint8_t SIZEOF_TCB = sizeof(TCB);

void setup_threads(TCB* tcb_ptr, uint8_t* stack_bottom_ptr,void* thread_function, int thread_pid)
{
 34a:	cf 93       	push	r28
 34c:	df 93       	push	r29
 34e:	cd b7       	in	r28, 0x3d	; 61
 350:	de b7       	in	r29, 0x3e	; 62
 352:	2a 97       	sbiw	r28, 0x0a	; 10
 354:	0f b6       	in	r0, 0x3f	; 63
 356:	f8 94       	cli
 358:	de bf       	out	0x3e, r29	; 62
 35a:	0f be       	out	0x3f, r0	; 63
 35c:	cd bf       	out	0x3d, r28	; 61
 35e:	9c 83       	std	Y+4, r25	; 0x04
 360:	8b 83       	std	Y+3, r24	; 0x03
 362:	7e 83       	std	Y+6, r23	; 0x06
 364:	6d 83       	std	Y+5, r22	; 0x05
 366:	58 87       	std	Y+8, r21	; 0x08
 368:	4f 83       	std	Y+7, r20	; 0x07
 36a:	3a 87       	std	Y+10, r19	; 0x0a
 36c:	29 87       	std	Y+9, r18	; 0x09
	// 先封栈底，栈底（也就是空栈栈顶）是PC指针的位置，即线程函数的指针
	// ATMEL的架构是从一般状态进入中断时先把手头执行的函数指针push进栈顶
	// 中断函数执行完毕后再把栈底的函数指针pop出栈顶
	// 整个过程是硬件自动执行的
	uint8_t* stack_top_ptr = stack_bottom_ptr + STACK_SIZE - 1;
 36e:	8d 81       	ldd	r24, Y+5	; 0x05
 370:	9e 81       	ldd	r25, Y+6	; 0x06
 372:	81 50       	subi	r24, 0x01	; 1
 374:	9e 4f       	sbci	r25, 0xFE	; 254
 376:	9a 83       	std	Y+2, r25	; 0x02
 378:	89 83       	std	Y+1, r24	; 0x01
	memset(stack_bottom_ptr,STACK_INIT_DATA,STACK_SIZE);
 37a:	8d 81       	ldd	r24, Y+5	; 0x05
 37c:	9e 81       	ldd	r25, Y+6	; 0x06
 37e:	40 e0       	ldi	r20, 0x00	; 0
 380:	52 e0       	ldi	r21, 0x02	; 2
 382:	63 e8       	ldi	r22, 0x83	; 131
 384:	70 e0       	ldi	r23, 0x00	; 0
 386:	03 d1       	rcall	.+518    	; 0x58e <memset>
	*stack_top_ptr     = 0x00;
 388:	89 81       	ldd	r24, Y+1	; 0x01
 38a:	9a 81       	ldd	r25, Y+2	; 0x02
 38c:	fc 01       	movw	r30, r24
 38e:	10 82       	st	Z, r1
	*(stack_top_ptr-1) = 0x00;
 390:	89 81       	ldd	r24, Y+1	; 0x01
 392:	9a 81       	ldd	r25, Y+2	; 0x02
 394:	01 97       	sbiw	r24, 0x01	; 1
 396:	fc 01       	movw	r30, r24
 398:	10 82       	st	Z, r1
	*(stack_top_ptr-2) = 0x00;
 39a:	89 81       	ldd	r24, Y+1	; 0x01
 39c:	9a 81       	ldd	r25, Y+2	; 0x02
 39e:	02 97       	sbiw	r24, 0x02	; 2
 3a0:	fc 01       	movw	r30, r24
 3a2:	10 82       	st	Z, r1
	stack_top_ptr -= 3;
 3a4:	89 81       	ldd	r24, Y+1	; 0x01
 3a6:	9a 81       	ldd	r25, Y+2	; 0x02
 3a8:	03 97       	sbiw	r24, 0x03	; 3
 3aa:	9a 83       	std	Y+2, r25	; 0x02
 3ac:	89 83       	std	Y+1, r24	; 0x01
	*stack_top_ptr     = (uint16_t) thread_function  & 0xFF;
 3ae:	8f 81       	ldd	r24, Y+7	; 0x07
 3b0:	98 85       	ldd	r25, Y+8	; 0x08
 3b2:	28 2f       	mov	r18, r24
 3b4:	89 81       	ldd	r24, Y+1	; 0x01
 3b6:	9a 81       	ldd	r25, Y+2	; 0x02
 3b8:	fc 01       	movw	r30, r24
 3ba:	20 83       	st	Z, r18
	*(stack_top_ptr-1) = (uint16_t) thread_function >> 0x08;
 3bc:	89 81       	ldd	r24, Y+1	; 0x01
 3be:	9a 81       	ldd	r25, Y+2	; 0x02
 3c0:	01 97       	sbiw	r24, 0x01	; 1
 3c2:	2f 81       	ldd	r18, Y+7	; 0x07
 3c4:	38 85       	ldd	r19, Y+8	; 0x08
 3c6:	23 2f       	mov	r18, r19
 3c8:	33 27       	eor	r19, r19
 3ca:	fc 01       	movw	r30, r24
 3cc:	20 83       	st	Z, r18
	*(stack_top_ptr-2) = 0x00;
 3ce:	89 81       	ldd	r24, Y+1	; 0x01
 3d0:	9a 81       	ldd	r25, Y+2	; 0x02
 3d2:	02 97       	sbiw	r24, 0x02	; 2
 3d4:	fc 01       	movw	r30, r24
 3d6:	10 82       	st	Z, r1
	stack_top_ptr -= 3;
 3d8:	89 81       	ldd	r24, Y+1	; 0x01
 3da:	9a 81       	ldd	r25, Y+2	; 0x02
 3dc:	03 97       	sbiw	r24, 0x03	; 3
 3de:	9a 83       	std	Y+2, r25	; 0x02
 3e0:	89 83       	std	Y+1, r24	; 0x01
	// 然后初始化各个寄存器，通用寄存器32bytes，状态寄存器1byte，PC寄存器2byte，共35bytes
	// 只需要覆写33个寄存器即可
	memset(stack_top_ptr-33,0x00,33);
 3e2:	89 81       	ldd	r24, Y+1	; 0x01
 3e4:	9a 81       	ldd	r25, Y+2	; 0x02
 3e6:	81 97       	sbiw	r24, 0x21	; 33
 3e8:	41 e2       	ldi	r20, 0x21	; 33
 3ea:	50 e0       	ldi	r21, 0x00	; 0
 3ec:	60 e0       	ldi	r22, 0x00	; 0
 3ee:	70 e0       	ldi	r23, 0x00	; 0
 3f0:	ce d0       	rcall	.+412    	; 0x58e <memset>
	// 然后把当前栈顶存到TCB里
	tcb_ptr->tcb_stackPointer  = stack_top_ptr - 33;
 3f2:	89 81       	ldd	r24, Y+1	; 0x01
 3f4:	9a 81       	ldd	r25, Y+2	; 0x02
 3f6:	9c 01       	movw	r18, r24
 3f8:	21 52       	subi	r18, 0x21	; 33
 3fa:	31 09       	sbc	r19, r1
 3fc:	8b 81       	ldd	r24, Y+3	; 0x03
 3fe:	9c 81       	ldd	r25, Y+4	; 0x04
 400:	fc 01       	movw	r30, r24
 402:	31 83       	std	Z+1, r19	; 0x01
 404:	20 83       	st	Z, r18
	tcb_ptr->tcb_status        = TCB_STATUS_REDAY;
 406:	8b 81       	ldd	r24, Y+3	; 0x03
 408:	9c 81       	ldd	r25, Y+4	; 0x04
 40a:	21 e0       	ldi	r18, 0x01	; 1
 40c:	fc 01       	movw	r30, r24
 40e:	25 83       	std	Z+5, r18	; 0x05
	tcb_ptr->tcb_pid		   = thread_pid;
 410:	29 85       	ldd	r18, Y+9	; 0x09
 412:	8b 81       	ldd	r24, Y+3	; 0x03
 414:	9c 81       	ldd	r25, Y+4	; 0x04
 416:	fc 01       	movw	r30, r24
 418:	24 83       	std	Z+4, r18	; 0x04
	tcb_ptr->tcb_delay_cyc_cnt = 0;
 41a:	8b 81       	ldd	r24, Y+3	; 0x03
 41c:	9c 81       	ldd	r25, Y+4	; 0x04
 41e:	fc 01       	movw	r30, r24
 420:	17 82       	std	Z+7, r1	; 0x07
 422:	16 82       	std	Z+6, r1	; 0x06
}
 424:	00 00       	nop
 426:	2a 96       	adiw	r28, 0x0a	; 10
 428:	0f b6       	in	r0, 0x3f	; 63
 42a:	f8 94       	cli
 42c:	de bf       	out	0x3e, r29	; 62
 42e:	0f be       	out	0x3f, r0	; 63
 430:	cd bf       	out	0x3d, r28	; 61
 432:	df 91       	pop	r29
 434:	cf 91       	pop	r28
 436:	08 95       	ret

00000438 <scheduling_thread>:
TCB threadList[MAX_THREADS]; // 线程列表
int currentThread=0;

#if THREAD_SCHEDULING_ROUND_ROBIN 
extern void scheduling_thread(void)
{
 438:	cf 93       	push	r28
 43a:	df 93       	push	r29
 43c:	cd b7       	in	r28, 0x3d	; 61
 43e:	de b7       	in	r29, 0x3e	; 62
	// TCB* currentThread_tcb = get_thread_by_pid(currentThread);
	currentThread = currentThread >= 1 ? 0:1; 
 440:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 444:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 448:	21 e0       	ldi	r18, 0x01	; 1
 44a:	18 16       	cp	r1, r24
 44c:	19 06       	cpc	r1, r25
 44e:	0c f4       	brge	.+2      	; 0x452 <scheduling_thread+0x1a>
 450:	20 e0       	ldi	r18, 0x00	; 0
 452:	82 2f       	mov	r24, r18
 454:	90 e0       	ldi	r25, 0x00	; 0
 456:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 45a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
}
 45e:	00 00       	nop
 460:	df 91       	pop	r29
 462:	cf 91       	pop	r28
 464:	08 95       	ret

00000466 <get_thread_by_pid>:
#endif // end  THREAD_SCHEDULING_PRIORITY



TCB* get_thread_by_pid(int pid)
{
 466:	cf 93       	push	r28
 468:	df 93       	push	r29
 46a:	1f 92       	push	r1
 46c:	1f 92       	push	r1
 46e:	cd b7       	in	r28, 0x3d	; 61
 470:	de b7       	in	r29, 0x3e	; 62
 472:	9a 83       	std	Y+2, r25	; 0x02
 474:	89 83       	std	Y+1, r24	; 0x01
	return &(threadList[pid]);
 476:	89 81       	ldd	r24, Y+1	; 0x01
 478:	9a 81       	ldd	r25, Y+2	; 0x02
 47a:	88 0f       	add	r24, r24
 47c:	99 1f       	adc	r25, r25
 47e:	88 0f       	add	r24, r24
 480:	99 1f       	adc	r25, r25
 482:	88 0f       	add	r24, r24
 484:	99 1f       	adc	r25, r25
 486:	8e 5f       	subi	r24, 0xFE	; 254
 488:	97 4f       	sbci	r25, 0xF7	; 247
}
 48a:	0f 90       	pop	r0
 48c:	0f 90       	pop	r0
 48e:	df 91       	pop	r29
 490:	cf 91       	pop	r28
 492:	08 95       	ret

00000494 <delay_thread_ms>:

void delay_thread_ms(int delay_interval_ms)
{
 494:	cf 93       	push	r28
 496:	df 93       	push	r29
 498:	00 d0       	rcall	.+0      	; 0x49a <delay_thread_ms+0x6>
 49a:	1f 92       	push	r1
 49c:	cd b7       	in	r28, 0x3d	; 61
 49e:	de b7       	in	r29, 0x3e	; 62
 4a0:	9c 83       	std	Y+4, r25	; 0x04
 4a2:	8b 83       	std	Y+3, r24	; 0x03
	cli();
 4a4:	f8 94       	cli
	TCB* current_thread_ptr				     = get_thread_by_pid(currentThread);
 4a6:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 4aa:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 4ae:	db df       	rcall	.-74     	; 0x466 <get_thread_by_pid>
 4b0:	9a 83       	std	Y+2, r25	; 0x02
 4b2:	89 83       	std	Y+1, r24	; 0x01
	current_thread_ptr->tcb_status			 = TCB_STATUS_SUSPENED;
 4b4:	89 81       	ldd	r24, Y+1	; 0x01
 4b6:	9a 81       	ldd	r25, Y+2	; 0x02
 4b8:	23 e0       	ldi	r18, 0x03	; 3
 4ba:	fc 01       	movw	r30, r24
 4bc:	25 83       	std	Z+5, r18	; 0x05
	#ifdef THREAD_TIME_INTERVAL_1MS
	current_thread_ptr->tcb_delay_cyc_cnt	 = delay_interval_ms;
 4be:	2b 81       	ldd	r18, Y+3	; 0x03
 4c0:	3c 81       	ldd	r19, Y+4	; 0x04
 4c2:	89 81       	ldd	r24, Y+1	; 0x01
 4c4:	9a 81       	ldd	r25, Y+2	; 0x02
 4c6:	fc 01       	movw	r30, r24
 4c8:	37 83       	std	Z+7, r19	; 0x07
 4ca:	26 83       	std	Z+6, r18	; 0x06
	THREAD_YIELD();
 4cc:	84 e8       	ldi	r24, 0x84	; 132
 4ce:	90 e0       	ldi	r25, 0x00	; 0
 4d0:	29 eb       	ldi	r18, 0xB9	; 185
 4d2:	39 e0       	ldi	r19, 0x09	; 9
 4d4:	fc 01       	movw	r30, r24
 4d6:	31 83       	std	Z+1, r19	; 0x01
 4d8:	20 83       	st	Z, r18
	#endif // THREAD_TIME_INTERVAL_1MS
	sei();
 4da:	78 94       	sei
}
 4dc:	00 00       	nop
 4de:	0f 90       	pop	r0
 4e0:	0f 90       	pop	r0
 4e2:	0f 90       	pop	r0
 4e4:	0f 90       	pop	r0
 4e6:	df 91       	pop	r29
 4e8:	cf 91       	pop	r28
 4ea:	08 95       	ret

000004ec <thread0_main>:
#include "user_func.h"



void thread0_main(void)
{
 4ec:	cf 93       	push	r28
 4ee:	df 93       	push	r29
 4f0:	1f 92       	push	r1
 4f2:	1f 92       	push	r1
 4f4:	cd b7       	in	r28, 0x3d	; 61
 4f6:	de b7       	in	r29, 0x3e	; 62
	int a = 1;
 4f8:	81 e0       	ldi	r24, 0x01	; 1
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	9a 83       	std	Y+2, r25	; 0x02
 4fe:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		PORTB |= 0xFF;
 500:	85 e2       	ldi	r24, 0x25	; 37
 502:	90 e0       	ldi	r25, 0x00	; 0
 504:	fc 01       	movw	r30, r24
 506:	80 81       	ld	r24, Z
 508:	85 e2       	ldi	r24, 0x25	; 37
 50a:	90 e0       	ldi	r25, 0x00	; 0
 50c:	2f ef       	ldi	r18, 0xFF	; 255
 50e:	fc 01       	movw	r30, r24
 510:	20 83       	st	Z, r18
		delay_us(a);
 512:	89 81       	ldd	r24, Y+1	; 0x01
 514:	9a 81       	ldd	r25, Y+2	; 0x02
 516:	f9 dd       	rcall	.-1038   	; 0x10a <delay_us>
		PORTB &= 0x00;
 518:	85 e2       	ldi	r24, 0x25	; 37
 51a:	90 e0       	ldi	r25, 0x00	; 0
 51c:	fc 01       	movw	r30, r24
 51e:	80 81       	ld	r24, Z
 520:	85 e2       	ldi	r24, 0x25	; 37
 522:	90 e0       	ldi	r25, 0x00	; 0
 524:	fc 01       	movw	r30, r24
 526:	10 82       	st	Z, r1
		delay_us(1000-a);
 528:	28 ee       	ldi	r18, 0xE8	; 232
 52a:	33 e0       	ldi	r19, 0x03	; 3
 52c:	89 81       	ldd	r24, Y+1	; 0x01
 52e:	9a 81       	ldd	r25, Y+2	; 0x02
 530:	a9 01       	movw	r20, r18
 532:	48 1b       	sub	r20, r24
 534:	59 0b       	sbc	r21, r25
 536:	ca 01       	movw	r24, r20
 538:	e8 dd       	rcall	.-1072   	; 0x10a <delay_us>
		a =  a < 997 ? a + 2 : 1;
 53a:	89 81       	ldd	r24, Y+1	; 0x01
 53c:	9a 81       	ldd	r25, Y+2	; 0x02
 53e:	85 3e       	cpi	r24, 0xE5	; 229
 540:	93 40       	sbci	r25, 0x03	; 3
 542:	24 f4       	brge	.+8      	; 0x54c <thread0_main+0x60>
 544:	89 81       	ldd	r24, Y+1	; 0x01
 546:	9a 81       	ldd	r25, Y+2	; 0x02
 548:	02 96       	adiw	r24, 0x02	; 2
 54a:	02 c0       	rjmp	.+4      	; 0x550 <thread0_main+0x64>
 54c:	81 e0       	ldi	r24, 0x01	; 1
 54e:	90 e0       	ldi	r25, 0x00	; 0
 550:	9a 83       	std	Y+2, r25	; 0x02
 552:	89 83       	std	Y+1, r24	; 0x01
	}
 554:	d5 cf       	rjmp	.-86     	; 0x500 <thread0_main+0x14>

00000556 <thread1_main>:
}

void thread1_main(void)
{
 556:	cf 93       	push	r28
 558:	df 93       	push	r29
 55a:	cd b7       	in	r28, 0x3d	; 61
 55c:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		delay_thread_ms(1);
 55e:	81 e0       	ldi	r24, 0x01	; 1
 560:	90 e0       	ldi	r25, 0x00	; 0
 562:	98 df       	rcall	.-208    	; 0x494 <delay_thread_ms>
		PORTB &= 0x00;
 564:	85 e2       	ldi	r24, 0x25	; 37
 566:	90 e0       	ldi	r25, 0x00	; 0
 568:	fc 01       	movw	r30, r24
 56a:	80 81       	ld	r24, Z
 56c:	85 e2       	ldi	r24, 0x25	; 37
 56e:	90 e0       	ldi	r25, 0x00	; 0
 570:	fc 01       	movw	r30, r24
 572:	10 82       	st	Z, r1
		delay_thread_ms(1);
 574:	81 e0       	ldi	r24, 0x01	; 1
 576:	90 e0       	ldi	r25, 0x00	; 0
 578:	8d df       	rcall	.-230    	; 0x494 <delay_thread_ms>
		PORTB |= 0xFF;
 57a:	85 e2       	ldi	r24, 0x25	; 37
 57c:	90 e0       	ldi	r25, 0x00	; 0
 57e:	fc 01       	movw	r30, r24
 580:	80 81       	ld	r24, Z
 582:	85 e2       	ldi	r24, 0x25	; 37
 584:	90 e0       	ldi	r25, 0x00	; 0
 586:	2f ef       	ldi	r18, 0xFF	; 255
 588:	fc 01       	movw	r30, r24
 58a:	20 83       	st	Z, r18
	}
 58c:	e8 cf       	rjmp	.-48     	; 0x55e <thread1_main+0x8>

0000058e <memset>:
 58e:	dc 01       	movw	r26, r24
 590:	01 c0       	rjmp	.+2      	; 0x594 <memset+0x6>
 592:	6d 93       	st	X+, r22
 594:	41 50       	subi	r20, 0x01	; 1
 596:	50 40       	sbci	r21, 0x00	; 0
 598:	e0 f7       	brcc	.-8      	; 0x592 <memset+0x4>
 59a:	08 95       	ret

0000059c <_exit>:
 59c:	f8 94       	cli

0000059e <__stop_program>:
 59e:	ff cf       	rjmp	.-2      	; 0x59e <__stop_program>
